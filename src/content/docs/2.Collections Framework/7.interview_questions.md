---
title: Common Interview Questions
---

## 1. What is the difference between ArrayList and LinkedList?

**Answer**: 
ArrayList and LinkedList are both List implementations but differ in their internal structure and performance characteristics:

- **Internal Structure**:
  - ArrayList: Backed by a resizable array
  - LinkedList: Implemented as a doubly-linked list

- **Performance**:
  - ArrayList: O(1) for random access, O(n) for insertions/deletions in the middle
  - LinkedList: O(n) for random access, O(1) for insertions/deletions once position is found

- **Memory Overhead**:
  - ArrayList: Lower memory overhead
  - LinkedList: Higher due to storing node pointers

- **Use Cases**:
  - ArrayList: Preferred for random access and storing data
  - LinkedList: Preferred for frequent insertions/deletions, especially at ends

## 2. How does HashMap work internally?

**Answer**: 
HashMap works by storing key-value pairs in an array of buckets:

1. When putting an element:
   - The key's hashCode() is calculated and modified (hash = key.hashCode() ^ (hash >>> 16))
   - The bucket index is determined by (hash & (capacity-1))
   - If the bucket is empty, the entry is placed there
   - If there's a collision, entries form a linked list (or a tree in Java 8+ when bucket size exceeds 8)

2. When getting an element:
   - The same hash calculation determines the bucket
   - The key's equals() method is used to find the correct entry in the bucket

3. Resizing:
   - Occurs when the load factor threshold is exceeded (default 0.75)
   - Creates a new array with double the capacity
   - Rehashes all entries to new positions

## 3. What is the difference between HashMap and Hashtable?

**Answer**: 

| Feature | HashMap | Hashtable |
|---------|---------|----------|
| Thread safety | Not thread-safe | Thread-safe (all methods synchronized) |
| Null keys/values | Allows one null key and multiple null values | Does not allow null keys or values |
| Performance | Generally better due to lack of synchronization | Slower due to synchronization overhead |
| Iterator | Fail-fast | Fail-fast |
| Legacy status | Modern implementation | Legacy class (since JDK 1.0) |
| Preferred alternative | Use ConcurrentHashMap for thread safety | Use HashMap or ConcurrentHashMap |

## 4. What is the difference between fail-fast and fail-safe iterators?

**Answer**: 

- **Fail-fast Iterators**:
  - Throw ConcurrentModificationException if the collection is modified while iterating
  - Work on the original collection
  - Examples: Iterator from ArrayList, HashMap, HashSet
  - Use a modification counter (modCount) to detect changes

- **Fail-safe Iterators**:
  - Don't throw exceptions if the collection is modified during iteration
  - Work on a copy of the collection
  - Examples: Iterator from ConcurrentHashMap, CopyOnWriteArrayList
  - May not reflect the latest state of the collection

## 5. What is the difference between Collection and Collections?

**Answer**: 

- **Collection**: An interface that represents a group of objects. It's the root interface in the collection hierarchy.

- **Collections**: A utility class that contains static methods for operating on collections, such as sorting, searching, synchronization, and creating unmodifiable views.

## 6. How do you sort a collection of custom objects?

**Answer**: There are two ways to sort custom objects:

1. **Implement Comparable interface**:
   ```java
   public class Employee implements Comparable<Employee> {
       private String name;
       private int age;
       
       // Constructor, getters, setters...
       
       @Override
       public int compareTo(Employee other) {
           return this.age - other.age; // Sort by age
       }
   }
   
   // Usage
   List<Employee> employees = new ArrayList<>();
   // Add employees...
   Collections.sort(employees); // Uses compareTo method
   ```

2. **Use a Comparator**:
   ```java
   // External comparator
   Comparator<Employee> nameComparator = new Comparator<Employee>() {
       @Override
       public int compare(Employee e1, Employee e2) {
           return e1.getName().compareTo(e2.getName());
       }
   };
   
   // Usage
   Collections.sort(employees, nameComparator);
   
   // Java 8+ lambda
   Collections.sort(employees, Comparator.comparing(Employee::getName));
   ```

## 7. What is the difference between List, Set, and Map?

**Answer**: 

- **List**: An ordered collection that allows duplicate elements. Elements can be accessed by their index.
  - Examples: ArrayList, LinkedList

- **Set**: A collection that cannot contain duplicate elements. Generally unordered.
  - Examples: HashSet, TreeSet, LinkedHashSet

- **Map**: An object that maps keys to values. Cannot contain duplicate keys.
  - Examples: HashMap, TreeMap, LinkedHashMap

## 8. What happens when a duplicate key is put into a HashMap?

**Answer**: When a duplicate key is put into a HashMap, the new value replaces the old value associated with that key. The put() method returns the previous value associated with the key, or null if there was no mapping for the key.

```java
Map<String, Integer> map = new HashMap<>();
map.put("key", 1);  // Returns null (no previous mapping)
Integer previous = map.put("key", 2);  // Returns 1 (previous value)
System.out.println(map.get("key"));  // Prints 2
```

## 9. What is the difference between TreeSet and HashSet?

**Answer**: 

| Feature | TreeSet | HashSet |
|---------|---------|--------|
| Ordering | Sorted (natural or by comparator) | Unordered |
| Implementation | Red-Black Tree | HashMap |
| Performance | O(log n) for add/remove/contains | O(1) for add/remove/contains |
| Null elements | Not allowed (Java 7+) | One null allowed |
| Memory usage | Less than HashSet | More than TreeSet |
| Use case | When order matters or range operations needed | When fast lookup is priority |

## 10. How do you create an immutable collection?

**Answer**: 

In Java 9+, you can use factory methods:
```java
// Immutable List
List<String> immutableList = List.of("a", "b", "c");

// Immutable Set
Set<String> immutableSet = Set.of("a", "b", "c");

// Immutable Map
Map<String, Integer> immutableMap = Map.of("a", 1, "b", 2, "c", 3);

// For larger maps
Map<String, Integer> largeMap = Map.ofEntries(
    Map.entry("a", 1),
    Map.entry("b", 2),
    // More entries...
);
```

In Java 8 and earlier:
```java
// Using Collections utility methods
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
List<String> immutableList = Collections.unmodifiableList(list);

// Similar methods for Set and Map
Set<String> immutableSet = Collections.unmodifiableSet(new HashSet<>());
Map<String, Integer> immutableMap = Collections.unmodifiableMap(new HashMap<>());
```

## 11. What is the difference between Iterator and ListIterator?

**Answer**: 

| Feature | Iterator | ListIterator |
|---------|----------|-------------|
| Direction | Forward only | Bidirectional (forward and backward) |
| Applicable to | All Collection types | Only List implementations |
| Add elements | Cannot add | Can add elements during iteration |
| Replace elements | Cannot replace | Can replace elements with set() |
| Index access | No index methods | Has nextIndex() and previousIndex() |

```java
// Iterator example
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    // Can remove but not add or replace
    if (someCondition) iterator.remove();
}

// ListIterator example
ListIterator<String> listIterator = list.listIterator();
while (listIterator.hasNext()) {
    int index = listIterator.nextIndex();
    String element = listIterator.next();
    // Can remove, add, or replace
    listIterator.set("new value");  // Replace current element
    listIterator.add("new element");  // Add after current position
}
```

## 12. What is the ConcurrentModificationException and how do you avoid it?

**Answer**: 
ConcurrentModificationException is thrown when a collection is modified while iterating over it using an iterator. This is the behavior of fail-fast iterators.

Ways to avoid it:

1. **Use Iterator's remove() method**:
   ```java
   Iterator<String> iterator = list.iterator();
   while (iterator.hasNext()) {
       String element = iterator.next();
       if (someCondition) {
           iterator.remove();  // Safe way to remove during iteration
       }
   }
   ```

2. **Use removeIf() (Java 8+)**:
   ```java
   list.removeIf(element -> someCondition(element));
   ```

3. **Use concurrent collections**:
   ```java
   List<String> list = new CopyOnWriteArrayList<>();
   // No ConcurrentModificationException when modifying during iteration
   ```

4. **Create a copy for iteration**:
   ```java
   for (String element : new ArrayList<>(originalList)) {
       if (someCondition) {
           originalList.remove(element);  // Safe because iterating over copy
       }
   }
   ```

## 13. How do you synchronize collections in Java?

**Answer**: There are several ways to synchronize collections in Java:

1. **Using Collections utility methods**:
   ```java
   List<String> syncList = Collections.synchronizedList(new ArrayList<>());
   Set<String> syncSet = Collections.synchronizedSet(new HashSet<>());
   Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());
   
   // Important: Iteration must be manually synchronized
   synchronized (syncList) {
       for (String item : syncList) {
           // Safe iteration
       }
   }
   ```

2. **Using concurrent collections**:
   ```java
   Map<String, Integer> concurrentMap = new ConcurrentHashMap<>();
   List<String> copyOnWriteList = new CopyOnWriteArrayList<>();
   Set<String> copyOnWriteSet = new CopyOnWriteArraySet<>();
   
   // No explicit synchronization needed for iteration
   for (String item : copyOnWriteList) {
       // Safe iteration
   }
   ```

3. **Using legacy thread-safe collections**:
   ```java
   Vector<String> vector = new Vector<>();  // Thread-safe list
   Hashtable<String, Integer> hashtable = new Hashtable<>();  // Thread-safe map
   ```

## 14. What is the difference between Enumeration and Iterator?

**Answer**: 

| Feature | Enumeration | Iterator |
|---------|-------------|----------|
| Package | java.util | java.util |
| Origin | Legacy (JDK 1.0) | Modern (JDK 1.2) |
| Method names | hasMoreElements(), nextElement() | hasNext(), next() |
| Remove operation | Cannot remove elements | Can remove with remove() |
| Fail-fast | Not fail-fast | Fail-fast |
| Usage | Legacy collections (Vector, Hashtable) | All modern collections |

## 15. What are the benefits of the Java Collections Framework?

**Answer**: 
The Java Collections Framework provides several benefits:

1. **Reduced programming effort**: Provides ready-to-use data structures and algorithms
2. **Increased performance**: Implementations are highly optimized
3. **Interoperability**: Common interfaces allow collections to work together
4. **Reduced effort to learn and use**: Consistent API across all collection types
5. **Reusability**: Generic implementations that work with any data type
6. **Extensibility**: Framework can be extended with custom implementations
